<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>deepClone</title>
</head>

<body>
    <script>
        var obj = {
            name: 'abc', //原始值
            age: 22, //原始值
            card: ['visa', 'master'], //引用值
            wife: { //引用值
                name: 'bcd', //原始值
                son: { //引用值
                    name: 'sss' //原始值
                }
            }
        }

        var obj1 = {

        }

        function deepClone(origin, target) {
            var target = target || {}, //判断是否传入target没有就创建一个空对象
                toStr = Object.prototype.toString, //判断是数组还是对象Object.prototype.toString.call()
                arrStr = '[object Arrary]'; //判断出来的数组值是'[object Arrary]'

            for (var prop in origin) { //循环遍历每一位
                if (origin.hasOwnProperty(prop)) { //排除原型上的属性，只拿自己的
                    if (origin[prop] != 'null' && typeof(origin[prop]) == 'object') { //判断引用值
                        target[prop] = toStr.call(origin[prop]) == arrStr ? [] : {}; //判断引用值是数组还是对象，分别建立相应的空对象/数组
                        deepClone(origin[prop], target[prop]); //递归操作，是原始值直接操作，不是原始值返回第一步继续循环
                    } else { //原始值直接clone
                        target[prop] = origin[prop];
                    }
                }
            }
            return target; //如没传入target，需要return回去
        }

        // Object.prototype.deepClone = function(origin, target) {
        //     var target = target || {}, //判断是否传入target没有就创建一个空对象
        //         toStr = Object.prototype.toString, //判断是数组还是对象Object.prototype.toString.call()
        //         arrStr = '[object Arrary]'; //判断出来的数组值是'[object Arrary]'

        //     for (var prop in origin) { //循环遍历每一位
        //         if (origin.hasOwnProperty(prop)) { //排除原型上的属性，只拿自己的
        //             if (origin[prop] != 'null' && typeof(origin[prop]) == 'object') { //判断引用值
        //                 target[prop] = toStr.call(origin[prop]) == arrStr ? [] : {}; //判断引用值是数组还是对象，分别建立相应的空对象/数组
        //                 deepClone(origin[prop], target[prop]); //递归操作，是原始值直接操作，不是原始值返回第一步继续循环
        //             } else { //原始值直接clone
        //                 target[prop] = origin[prop];
        //             }
        //         }
        //     }
        //     return target; //如没传入target，需要return回去
        // }

        deepClone(obj, obj1);

        obj.card.push('110'); //后续添加的属性不会影响目标
    </script>
</body>

</html>